\documentclass[acmtocl]%{acmtrans2m}%
{boviktrans}

\sloppypar

\usepackage{dashrule}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{stmaryrd}

\sloppypar

\newcommand{\seq}[3]{{#1};{#2} \longrightarrow {#3} \mathstrut}

\newcommand{\urfoc}[3]{{#1};{#2} \longrightarrow [{#3}] \mathstrut}
\newcommand{\ulfoc}[4]{{#1};{#2} \,[#3] \longrightarrow {#4} \mathstrut}
\newcommand{\uinv}[4]{{#1};{#2};{#3} \longrightarrow {#4} \mathstrut}

\newcommand{\stableR}[1]{{#1}\,\mathit{stable_R} \mathstrut}
\newcommand{\stableL}[1]{{#1}\,\mathit{stable_L} \mathstrut}
\newcommand{\one}{{\bf 1}}

\markboth{Simmons \& Murphy}{A modest proposal for the purity of programming}

\title{A modest proposal for the purity of programming}
\author{Robert J. Simmons \and Tom Murphy VII}

\begin{abstract}
  Terrible ideas permeate the world of programming languages, and the
  harm that these ideas do is lasting. Academic research is intended
  to ameloriate some of this harm, but the connection between academic
  PL research and industry grows ever more tenuous. This harms both
  realms. Terrible ideas continue to hold back the benefits that
  computer science and software enginnering seek to bring to the
  world.  On the other side, we should note the demoralizing effect of
  this tendency on academic PL research: why work on ``practical''
  research if you will be universally ignored?

  The more principled among us might suggest that we continue to
  generate the best ideas and see what happens, that the right ideas
  will win in time. The time for such velvet-glove approaches is long
  past. This is a war, and it is time to use all the resources at our
  disposal. We propose a method and apparatus to save the world from
  itself.
\end{abstract}

\category{F.4.1}{Theory of Computation}{Mathematical Logic}[Proof theory]
            
\terms{} 
            
\keywords{}

\begin{document}

\maketitle

\section{Introduction}

Why are programming langauges important? Why are they broken? What is our approach to fixing it?

\subsection{Primer on patent law}

Patent law is 

How does patent law work, and how does it allow us to stomp out bullshit?

\subsubsection{Unreasonable and non-discriminatory terms}

Standards bodies require member organizations to adhere to the mostly
ill-defined requirement of using {\it reasonable and
  non-discriminatory terms}, RAND for short, for any and all patents
owned by those organizations that pertain to the standard.

To see why this is important, consider a standards body with
representatives from 57 companies all working on a new standard for
Carrier Pidgeon Message Formatting modernizing RFC 1149. BBN Labs has
a new patent on avian foot massage technology \cite{ebert}, and without
revealing this fact to the consortium they incorporate the requirement
to 

\subsection{Base coat on patent trolls}

- different levels of patent from rock solid to pure troll-threats

We are going up against some of the biggest companies in the world, such as Larry Wall and Guido van Rossum.

\subsubsection{The chillaxing effect}

\subsection{Shellac on lost opportunities}


Examples of history: SIGBOVIK/Milner idea


\section{Examples}


Coming up with bad ideas for programming languages is very easy. The
challenge is to come up with ideas that are broad enough to cover many
possible instantiations of the idea, specific enough to be patentable,
and likely to be encountered in real upstart languages, where they can
be stamped out. As usual in science, our approach is stochastic; we
simply generate as many patents as we can. Many patents will never be
useful in the fight against bad programming languages, but these cause
no harm.\!\footnote{Informal studies in CMU's Principles of
  Programming group have shown preliminary evidence that bad
  programming languages can actually cause physical harm among those
  that have established taste and predisposition to logic. Observed
  effects include facepalms and grimaces, nausea, fatigue, emotional
  lability (uncontrolled weeping or laughing), Bobface (first identified
  by William J.~Lovas), and dry mouth. Other harm is more direct, such
  as lacerations or bruises by being throttled by academic advisors.
  If this proves to be a problem, simple safety measures such as biohazard
  suits, coordinate-transform and other reversible mind-encryption systems,
  or simply employing the inadverse, may be used.}
As a demonstration, this section contains a list of bad programming language
ideas that we came up with, no sweat. Cringe away:

\begin{enumerate}
\item A programming language where everything is
\item The input programs are written as recipes
\item You just give examples of what a function should do in certain circumstances, and when it encounters an input that is not specified it\ldots
  \begin{enumerate}
    \item \ldots linearly interpolates between known answers
    \item \ldots uses genetic programming to come up with a short program that satisfies your constraints and also works on this input
    \item \ldots pauses and waits for the programmer to finish the program
    \item \ldots asks the user what the answer should be, adding it to the database
    \item \ldots searches for code on the internet that meets the example-based specs, and prompts the programmer or user as to which one should be used
    \item \ldots
  \end{enumerate}
\item Input programs are written in musical notation
\item Input programs are graphical diagrams written in UML, XML, flow charts, as maps, circuits, or two-dimensional ASCII
\item Programs are written in three-dimensional layered text, perhaps in different colors and with alpha channels, to specify interleaved threads
\item Everything in the language is just a\ldots
   \begin{enumerate}
     \item \ldots string literal, including keywords
     \item \ldots capital {\it i} or lowercase {\it L}
     \item \ldots continuously differentiable probability density function
     \item \ldots hash table mapping hash tables to hash tables
     \item \ldots $n$-tuple
     \item \ldots finite permutation
     \item \ldots 7-bit integer
     \item \ldots coercion
     \item \ldots rule
     \item \ldots exception, except exceptions; those are normal
     \item \ldots arbitrary-precision rational number
     \item \ldots priority queue, fibonacci heap, b-tree, pixel, regular expression, presheaf, commutative diagram, metaphor, monad
     \item \ldots MP3
     \item \ldots SMS
     \item \ldots mutex
     \item \ldots non-uniform rational b-spline
   \end{enumerate}
\item Instead of stack-based control-flow, use queue-based, tree-based, dataflow-network-based
\item 4/3 CPS
\item Every value is represented as the 256-bit content hash; elimination forms are distributed hashtable lookups; revision control is built into the concrete syntax of the language
\item Unification always succeeds, forking the program with each of the two expressions to be unified substituted in that position; only if both fail does unification fail
\item Realize every program you wish to write as actually the test case for a metaprogram that generates the program
\item Language with only 20 keywords, one for each of the SPEC benchmarks
\item Language with only one keyword, whose semantics implements a compiler for the language itself
\item {\tt call-ac}, call with all continuations
\item Second-class data: All data must be top-level global declarations, and can't change. Functions are first-class.
\item Gesture-based concrete syntax
\item Programs are realized as dashboards with knobs, buttons, and cable connections between them
\item No matter what, the program keeps going, attempting to repair itself and keep trying actions that fail
\item Programs are abstract geometric shapes
\item Type has type \ldots
  \begin{enumerate}
    \item type
    \item int
    \item kind
    \item type $\rightarrow$ type
    \item object
    \item null
  \end{enumerate}
\item To protect against the problem where sometimes someone called a function with an empty string, ``emptyable'' types, which include all values of the type except the ``empty'' one (\verb+""+, 0, NaN, 0.0, nil, \verb+{}+, false, etc.).
\item To work around the global {\tt errno} problem, every value of a type includes the possibility of integers standing for an error code
\item Lazy natural (co-)numbers, where the output of a numeric program is only a lower bound that may get higher as it continues computing
\item A language where the compiler is integrated into the language as a feature, which takes first class source code to first class compiled binaries, within the language
\item There's a global registry, in the world, and whenever a function returns, you check to see if any function in the world has registered a hook to process it
\end{enumerate}

You see how easy this is? If you are a programming language expert you
might even have thought of some langauges that already use these
ideas. If so, {\it this is all the more reason to support our
  foundation}, because had we started earlier, we could have saved the
world some trouble!

It is worthwhile to try to acquire patents that are very broad, since
these can be used to attack almost any language, even one with
unanticipated bad ideas. For example:


% XXX minipage?
\subsection{Method and apparatus for attaching state to an object}

This patent describes a method and apparatus for attaching state to
objects in computer programs. The invention consists of a symbolic
program running in computer memory and an object (which may be a value,
hash table, list, function, binary data, array, vector, $n$-tuple,
presheaf, source file, class, run-time exception, finite or infinite
tape, or isomorphic representation). The claims are as follows:

1.\quad A system for attaching state to the said object \\

2.\quad The method of claim 1 where the state is binary data \\

3.\quad The method of claim 1 where the state is an assertion about the behavior of the object \\

4.\quad The method of claim 1 where the state is itself an object \\

5.\quad The method of claim 4 where the state is the same object, or some property therein \\

6.\quad The methods of claims 1--5 where the apparatus of attachment is reference \\
\qquad 6.a.\quad Reference by pointer \\
\qquad 6.b.\quad Reference by index \\
\qquad 6.c.\quad Reference by symbolic identifier \\
\qquad 6.c.\quad Representations isomorphic to those in claims 6.a.--6.c. \\

7.\quad The methods of claims 1--5 where the apparatus of attachment is containment \\

{\it (etc.)}

\subsection{Method and apparatus for determining the control flow of programs}

This patent describes a method and apparatus for determining the
control flow in computer programs. The invention consists of a
symbolic program running in computer memory, with a notion of {\it
  current} and {\it next} state (which may be an instruction pointer,
index, expression to evaluate, continuation, value, covalue, stack,
queue, execution context, thread or thread pool, process image,
cursor, tape head, phonograph stylus, or isomorphic
representation). The claims are as follows:

1.\quad A system for determining the next state from the previous state \\

2.\quad The method of claim 1, where the determination includes the contents of the program's memory \\

3.\quad The method of claim 1, where the determination includes the current state \\

4.\quad The method of claim 1, where the determination includes external inputs \\

5.\quad The method of claim 1, where the determination includes nondeterministic factors \\

6.\quad The method of claim 1, where the determination is fixed ahead of time \\

{\it (etc.)}

\section{The /dev/urand Foundation}

tom

UnReasonable and Not-not Discriminatory

\section{Lawsuits are coming}

languages that we are coming after


\begin{thebibliography}{1}


\bibitem{ebert}
Ebert, Michael A.
\newblock ``Corrugated recreational device for pets.''
\newblock Patent Application 11/757,456.
\newblock Filed June 4, 2007.

\bibitem{simmons10}
Simmons, Robert J., Nels E. Beckman, and Dr. Tom Murphy VII, Ph.D.
\newblock ``Functional Perl: Programming with Recursion Schemes in Python.''
\newblock In {\it SIGBOVIK 2010}.

\end{thebibliography}

\end{document}
