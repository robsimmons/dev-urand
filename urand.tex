\documentclass[acmtocl]%{acmtrans2m}%
{boviktrans}

\usepackage{dashrule}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{stmaryrd}

\newcommand{\seq}[3]{{#1};{#2} \longrightarrow {#3} \mathstrut}

\newcommand{\urfoc}[3]{{#1};{#2} \longrightarrow [{#3}] \mathstrut}
\newcommand{\ulfoc}[4]{{#1};{#2} \,[#3] \longrightarrow {#4} \mathstrut}
\newcommand{\uinv}[4]{{#1};{#2};{#3} \longrightarrow {#4} \mathstrut}

\newcommand{\stableR}[1]{{#1}\,\mathit{stable_R} \mathstrut}
\newcommand{\stableL}[1]{{#1}\,\mathit{stable_L} \mathstrut}
\newcommand{\one}{{\bf 1}}

\markboth{Robert J. Simmons, {\it et al.}}{A modest proposal for the purity of programming}

\title{A modest proposal for the purity of programming}
\author{Robert J. Simmons \and Tom Murphy VII}

\begin{abstract}
  Terrible ideas permeate the world of programming languages, and the
  harm that these ideas do is lasting. Academic research is intended
  to ameloriate some of this harm, but the connection between academic
  PL research and industry grows ever more tenuous. This harms both
  realms. Terrible ideas continue to hold back the benefits that
  computer science and software enginnering seek to bring to the
  world.  On the other side, we should note the demoralizing effect of
  this tendency on academic PL research: why work on ``practical''
  research if you will be universally ignored?

  The more principled among us might suggest that we continue to
  generate the best ideas and see what happens, that the right ideas
  will win in time. The time for such velvet-glove approaches is long
  past. This is a war, and it is time to use all the resources at our
  disposal. We propose a method and apparatus to save the world from
  itself.
\end{abstract}

\category{F.4.1}{Theory of Computation}{Mathematical Logic}[Proof theory]
            
\terms{} 
            
\keywords{}

\begin{document}

\maketitle

Da da da

\section{Introduction}

Why are programming langauges important? Why are they broken? What is our approach to fixing it?

How does patent law work, and how does it allow us to stomp out bullshit?

Examples of history: SIGBOVIK/Milner idea

- different levels of patent from rock solid to pure troll-threats

We are going up against some of the biggest companies in the world, such as Larry Wall and Guido van Rossum.

The chillaxing effect

\section{Examples}


Coming up with bad ideas for programming languages is very easy. The
challenge is to come up with ideas that are broad enough to cover many
possible instantiations of the idea, specific enough to be patentable,
and likely to be encountered in real upstart languages, where they can
be stamped out. As usual in science, our approach is stochastic; we
simply generate as many patents as we can. Many patents will never be
useful in the fight against bad programming languages, but these cause
no harm.\!\footnote{Informal studies in CMU's Principles of
  Programming group have shown preliminary evidence that bad
  programming languages can actually cause physical harm among those
  that have established taste and predisposition to logic. Observed
  effects include facepalms and grimaces, nausea, fatigue, emotional
  lability (uncontrolled weeping or laughing), Bobface (first identified
  by William J.~Lovas), and dry mouth. Other harm is more direct, such
  as lacerations or bruises by being throttled by academic advisors.
  If this proves to be a problem, simple safety measures such as biohazard
  suits, coordinate-transform and other reversible mind-encryption systems,
  or simply employing the inadverse, may be used.}
As a demonstration, this section contains a list of bad programming language
ideas that we came up with, no sweat. Cringe away:

\begin{enumerate}
\item A programming language where everything is
\item The input programs are written as recipes
\item You just give examples of what a function should do in certain circumstances, and when it encounters an input that is not specified it\ldots
  \begin{enumerate}
    \item \ldots linearly interpolates between known answers
    \item \ldots uses genetic programming to come up with a short program that satisfies your constraints and also works on this input
    \item \ldots pauses and waits for the programmer to finish the program
    \item \ldots asks the user what the answer should be, adding it to the database
    \item \ldots searches for code on the internet that meets the example-based specs, and prompts the programmer or user as to which one should be used
    \item \ldots
  \end{enumerate}
\item Input programs are written in musical notation
\item Input programs are graphical diagrams written in UML, XML, flow charts, as maps, circuits, or two-dimensional ASCII
\item Programs are written in three-dimensional layered text, perhaps in different colors and with alpha channels, to specify interleaved threads
\item Everything in the language is just a\ldots
   \begin{enumerate}
     \item \ldots string literal, including keywords
     \item \ldots capital {\it i} or lowercase {\it L}
     \item \ldots continuously differentiable probability density function
     \item \ldots hash table mapping hash tables to hash tables
     \item \ldots $n$-tuple
     \item \ldots finite permutation
     \item \ldots 7-bit integer
     \item \ldots rule
     \item \ldots exception, except exceptions; those are normal
     \item \ldots arbitrary-precision rational number
     \item \ldots priority queue, fibonacci heap, b-tree, pixel, regular expression, presheaf, commutative diagram, monad
     \item \ldots MP3
     \item \ldots mutex
     \item \ldots non-uniform rational b-spline
   \end{enumerate}
\item Every value is represented as the 256-bit content hash; elimination forms are distributed hashtable lookups; revision control is built into the concrete syntax of the language
\item Unification always succeeds, forking the program with each of the two expressions to be unified substituted in that position; only if both fail does unification fail
\item Realize every program you wish to write as actually the test case for a metaprogram that generates the program
\item Language with only 20 keywords, one for each of the SPEC benchmarks
\item Language with only one keyword, whose semantics implements a compiler for the language itself
\item {\tt call-ac}, call with all continuations
\item Second-class data: All data must be top-level global declarations, and can't change. Functions are first-class.
\item Gesture-based concrete syntax
\item Programs are realized as dashboards with knobs, buttons, and cable connections between them
\item No matter what, the program keeps going, attempting to repair itself and keep trying actions that fail
\item Programs are abstract geometric shapes
\end{enumerate}

You see how easy this is? If you are a programming language expert you
might even have thought of some langauges that already use these
ideas. If so, {\it this is all the more reason to support our
  foundation}, because had we started earlier, we could have saved the
world some trouble!

\section{The /dev/urand Foundation}

tom

UnReasonable and Not-not Discriminatory

\section{Lawsuits are coming}

languages that we are coming after

\end{document}
